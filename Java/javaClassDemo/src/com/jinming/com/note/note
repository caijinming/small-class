面向过程 c  侧重于解决问题，不考虑重用。
面向对象 c++  侧重于标准，重用。 三大特性： 封装性 ， 继承性， 多态性。

class 是引用类型，声明的时候最好用默认值null初始化。
堆内存：保存的是对象的具体信息。在Java中堆内存的空间开辟是通过new 来完成的。
栈内存：保存的是一块堆内存的地址。

Java 字符串是引用类型，字符串不可变。 字符串的不可变是指字符串内容不可变，指向是可以改变的。
Java 可变参数格式 （参数类型 ... 参数名） 或者 (String[] 参数名)

构造方法
1. 类默认会自动创建一个无参数的构造方法。
2. 构造方法的结构:  访问限制  + 类名 + 参数或无参数  {}
3. 自己创建构造方法，系统创建的将不会再创建。
4. 可以创建多个构造方法。

方法重载
1. 方法重载的返回值类型通常都是相同的，方法名相同，但各自的参数不同。

继承
1. 使用关键字extends来实现继承， Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有Object特殊，它没有父类.
2. 继承的子类不能访问父类 private 访问修饰的变量，要想能访问需要把private改为protected.
3. 如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法.
4. 即子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的.
5. final 修饰的类，那么任何类都不能从此类中继承。
6. 对象赋值。一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting) 这种是被允许的.把一个父类类型强制转型为子类类型，就是向下转型（downcasting)
这种情况是会报错，不支持的.因此通常用instanceof操作符,判断一个变量所指向的实例是否是指定类型，或者这个类型的子类.

多态
继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态。
覆写Object方法
因为所有的class最终都继承自Object，而Object定义了几个重要的方法：
toString()：把instance输出为String；
equals()：判断两个instance是否逻辑相等；
hashCode()：计算一个instance的哈希值。

final 修饰: final修饰的方法可以阻止被覆写；final修饰的class可以阻止被继承；final修饰的field必须在创建对象时初始化，随后不可修改

抽象类
1. 如果一个class定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用abstract修饰。因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。
使用abstract修饰的类就是抽象类。我们无法实例化一个抽象类。
2. 抽象类本身被设计成只能用于被继承。

抽象编程
1. 上层代码只定义规范; 具体的业务逻辑由不同的子类实现，调用者并不关心。 这种实现子类型的方式，称为面向抽象编程。

接口
1. 使用interface 关键字来定义接口; 接口里面全部是抽象方法。
2. 在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface，类去实现一个interface时，需要使用implements关键字。
3. 一个interface可以继承自另一个interface.
4. 再接口中，可以定义default修饰的方法。实现类可以不必覆写default方法。default方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。
如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。

静态字段和静态方法
1. 使用关键字static修饰。
2. 静态字段属于所有实例“共享”的字段，实际上是属于class的字段.
3. 静态字段或方法通过类名.访问。
4. 调用静态方法不需要实例，无法访问this，但可以访问静态字段和其他静态方法.
5. 因为interface是一个纯抽象类，所以它不能定义实例字段。但是，interface是可以有静态字段的，并且静态字段必须为final类型。

引用类型可以赋值为null，表示空，但基本类型不能赋值为null：
int 和 Integer 相互转换
/*Integer n = 100; // 编译器自动使用Integer.valueOf(int)
  int x = n; // 编译器自动使用Integer.intValue()
  这种直接把int变为Integer的赋值写法，称为自动装箱（Auto Boxing），反过来，把Integer变为int的赋值写法，称为自动拆箱（Auto Unboxing）。
  注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码*/


// 单例类
    //1. 只允许该类创建一个对象，为了避免自由创建该类的实例，需要把构造器用private 隐藏起来。
    //2. 需要提供一个public方法做为类的访问点，用于创建该类对象，且需要static 修饰，因为调用这个方法的只能是类。
    //3. 该类必须缓存已经创建的对象，否则无法知道是否曾经创建过对象。隐藏需要一个static修饰的成员变量，因为成员变量需要在静态方法里访问。

Java所有的包装类型和String都是不变类。
自定义不可变类特点
1. 使用private和final修饰符来修饰该类的成员变量.
2. 提供带参数的构造器，用于根据传入参数初始化类里的成员变量
3. 仅为类的成员变量提供getter方法，不提供setter方法
4. 如果有必要，重写Object类的equals()方法和hashCode()方法.

JavaBean
符合下面规范特点的类定义, 这种类就叫Javabean，javaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输.
1. 若干private实例字段；
2. 通过public方法来读写实例字段。

枚举类
1. 使用enum定义的枚举类是一种引用类型。enum类型总是继承自java.lang.Enum，且无法被继承。
2. 只能定义出enum的实例，而无法通过new操作符创建enum的实例；定义的每个实例都是引用类型的唯一实例.

异常处理
1. Java内置了一套异常处理机制，总是使用异常来表示错误。
2. 异常是一种class，因此它本身带有类型信息。异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离了
3. Throwable是异常体系的根，它继承自Object。Throwable有两个体系：Error和Exception，Error表示严重的错误，程序对此一般无能为力；
而Exception则是运行时的错误，它可以被捕获并处理。
4. 使用异常来表示错误，并通过try ... catch捕获异常.
5. RuntimeException无需强制捕获，非RuntimeException（Checked Exception）需强制捕获，或者用throws声明；
6. 使用try ... catch ... finally时：多个catch语句的匹配顺序非常重要，子类必须放在前面；finally语句保证了有无异常都会执行，它是可选的；

NullPointerException 空指针
成员变量在定义时初始化：空字符串""而不是默认的null可避免很多NullPointerException

断言
断言（Assertion）是一种调试程序的方式。在Java中，使用assert关键字来实现断言。

反射



